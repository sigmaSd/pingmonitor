<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="./assets/material-symbols.css" />
    <style>
      :root {
        --bg-color: #f5f5f7;
        --chart-bg: #ffffff;
        --text-color: #333333;
        --grid-color: rgba(0, 0, 0, 0.1);
        --chart-border: rgba(75, 192, 192, 1);
        --chart-fill: rgba(75, 192, 192, 0.2);
        --toggle-bg: #e0e0e0;
        --header-bg: #ffffff;
        --header-border: #e0e0e0;
        --input-bg: #ffffff;
        --input-border: #cccccc;
      }

      :root.dark-theme {
        --bg-color: #121212;
        --chart-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --grid-color: rgba(255, 255, 255, 0.1);
        --chart-border: rgba(75, 192, 255, 1);
        --chart-fill: rgba(75, 192, 255, 0.2);
        --toggle-bg: #333333;
        --header-bg: #1e1e1e;
        --header-border: #333333;
        --input-bg: #2d2d2d;
        --input-border: #444444;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s, color 0.3s;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.5rem;
        background-color: var(--header-bg);
        border-bottom: 1px solid var(--header-border);
        flex-shrink: 0;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        z-index: 10;
        gap: 1rem;
      }

      .error-banner {
        background-color: #ff5252;
        color: white;
        padding: 0.5rem 1.5rem;
        text-align: center;
        font-weight: 500;
        display: none;
        flex-shrink: 0;
        animation: slideDown 0.3s ease-out;
      }

      @keyframes slideDown {
        from {
          transform: translateY(-100%);
        }
        to {
          transform: translateY(0);
        }
      }

      .controls-area {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-grow: 1;
        max-width: 600px;
      }

      .host-input {
        padding: 0.5rem 0.8rem;
        border-radius: 6px;
        border: 1px solid var(--input-border);
        background: var(--input-bg);
        color: var(--text-color);
        font-family: inherit;
        font-size: 0.9rem;
        width: 180px;
        outline: none;
        transition: border-color 0.2s;
      }

      .host-input:focus {
        border-color: var(--chart-border);
      }

      .control-btn {
        background: var(--toggle-bg);
        color: var(--text-color);
        border: none;
        border-radius: 6px;
        padding: 0.4rem; /* Adjusted for icons */
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 36px;
        height: 36px;
      }

      .control-btn:hover {
        background-color: var(--chart-border);
        color: white;
      }

      .control-btn .material-symbols-outlined {
        font-size: 20px;
      }

      #updateHostBtn {
        display: none; /* Hidden by default */
        font-weight: 600;
        padding: 0 0.8rem;
        width: auto;
      }

      .divider {
        width: 1px;
        height: 24px;
        background-color: var(--header-border);
        margin: 0 0.5rem;
      }

      .stats-container {
        display: flex;
        gap: 1.5rem;
        font-size: 0.9rem;
        margin-left: auto;
      }

      .stat-box {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .stat-label {
        opacity: 0.6;
        font-weight: 500;
      }

      .stat-value {
        font-weight: 600;
        font-family: "Consolas", "Monaco", monospace;
        font-size: 1.2rem;
      }

      .chart-area {
        flex-grow: 1;
        position: relative;
        width: 100%;
        padding: 1rem;
        min-height: 300px;
      }

      .chart-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
      }

      @media (max-width: 800px) {
        .top-bar {
          flex-wrap: wrap;
          padding: 0.5rem;
        }
        .controls-area {
          order: 1;
          width: 100%;
          max-width: none;
          justify-content: space-between;
        }
        .host-input {
          width: 100%;
        }
        .stats-container {
          order: 2;
          width: 100%;
          justify-content: space-between;
          padding-top: 10px;
          border-top: 1px solid var(--header-border);
          margin-left: 0;
        }
      }

      .network-bar {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        padding: 0.5rem 1.5rem;
        background-color: var(--bg-color);
        font-size: 0.85rem;
        gap: 1.5rem;
        flex-shrink: 0;
        opacity: 0.8;
      }
      .network-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .network-item span:last-child {
        cursor: pointer;
        transition: all 0.2s;
        padding: 2px 4px;
        border-radius: 4px;
      }
      .network-item span:last-child:hover {
        background-color: var(--toggle-bg);
        color: var(--chart-border);
      }
      .network-label {
        font-weight: 600;
        color: var(--chart-border);
      }
    </style>
  </head>
  <body>
    <header class="top-bar">
      <div class="controls-area">
        <input
          type="text"
          id="hostInput"
          value="1.1.1.1"
          placeholder="Host/IP"
          class="host-input"
          spellcheck="false"
        />
        <button id="updateHostBtn" class="control-btn" title="Update Host">
          Update
        </button>
        <div class="divider"></div>
        <button id="pauseBtn" class="control-btn" title="Pause/Resume">
          <span class="material-symbols-outlined">pause</span>
        </button>
      </div>

      <div class="stats-container">
        <div class="stat-box">
          <span class="stat-label">Current</span>
          <span class="stat-value" id="currentPing">-- ms</span>
        </div>
        <div class="stat-box">
          <span class="stat-label">Avg</span>
          <span class="stat-value" id="avgPing">-- ms</span>
        </div>
        <div class="stat-box">
          <span class="stat-label">Max</span>
          <span class="stat-value" id="maxPing">-- ms</span>
        </div>
        <div class="divider"></div>
        <div class="stat-box">
          <span class="stat-label">↓</span>
          <span class="stat-value" id="downloadSpeed">--</span>
        </div>
        <div class="stat-box">
          <span class="stat-label">↑</span>
          <span class="stat-value" id="uploadSpeed">--</span>
        </div>
      </div>
    </header>

    <div class="network-bar">
      <div class="network-item">
        <span class="network-label">Public IP:</span>
        <span id="publicIp" title="Click to copy">Loading...</span>
      </div>
      <div class="network-item">
        <span class="network-label">Local IP:</span>
        <span id="localIp" title="Click to copy">Loading...</span>
      </div>
    </div>

    <div id="errorBanner" class="error-banner"></div>

    <main class="chart-area">
      <div class="chart-wrapper">
        <canvas id="pingChart"></canvas>
      </div>
    </main>

    <script>
      const ws = new WebSocket("ws://" + window.location.host);
      const ctx = document.getElementById("pingChart").getContext("2d");
      const hostInput = document.getElementById("hostInput");
      const updateHostBtn = document.getElementById("updateHostBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const errorBanner = document.getElementById("errorBanner");
      const publicIpEl = document.getElementById("publicIp");
      const localIpEl = document.getElementById("localIp");

      // Copy to clipboard helper
      function copyWithFeedback(el) {
        const originalText = el.textContent;
        if (
          originalText === "Loading..." || originalText === "Copied!"
        ) return;

        navigator.clipboard.writeText(originalText).then(() => {
          el.textContent = "Copied!";
          el.style.color = "#4CAF50";
          setTimeout(() => {
            el.textContent = originalText;
            el.style.color = "";
          }, 1000);
        });
      }

      publicIpEl.addEventListener(
        "click",
        () => copyWithFeedback(publicIpEl),
      );
      localIpEl.addEventListener(
        "click",
        () => copyWithFeedback(localIpEl),
      );

      // let pingValues = [];
      const MAX_DATA_POINTS = 60;
      const REMOVE_CHUNK_SIZE = 10;

      // State
      let isPaused = false;
      let lastReceivedTime = Date.now();
      const PING_INTERVAL = 1000;
      let currentHost = "1.1.1.1";

      // Chart setup
      const chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Ping (ms)",
              data: [],
              borderColor: "rgba(75, 192, 192, 1)",
              backgroundColor: "rgba(75, 192, 192, 0.2)",
              borderWidth: 2,
              fill: true,
              tension: 0.2,
              pointRadius: 3,
              spanGaps: true,
              segment: {
                borderColor: (ctx) =>
                  ctx.p1.parsed.y === 0 ? "#ff6b6b" : undefined,
              },
              pointBackgroundColor: (ctx) =>
                ctx.parsed?.y === 0
                  ? "#ff6b6b"
                  : ctx.chart.data.datasets[0].borderColor,
              pointBorderColor: (ctx) =>
                ctx.parsed?.y === 0
                  ? "#ff6b6b"
                  : ctx.chart.data.datasets[0].borderColor,
            },
          ],
        },
        options: {
          animation: { duration: 500, easing: "easeOutQuad" },
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: "index" },
          scales: {
            y: {
              type: "linear",
              display: true,
              position: "left",
              beginAtZero: false,
              grace: "5%",
              grid: { color: "rgba(0,0,0,0.05)" },
              ticks: { color: "#333", font: { size: 14 } },
            },
            x: {
              grid: { display: false, color: "rgba(0,0,0,0.05)" },
              ticks: {
                color: "#333",
                maxRotation: 0,
                autoSkip: true,
                maxTicksLimit: 8,
                font: { size: 14 },
              },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: "rgba(255,255,255,0.9)",
              titleColor: "#000",
              bodyColor: "#333",
              borderColor: "rgba(0,0,0,0.1)",
              borderWidth: 1,
              padding: 10,
              cornerRadius: 8,
              displayColors: false,
            },
          },
        },
      });

      // Theme logic
      let darkMode = window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      function applyTheme() {
        document.documentElement.classList.toggle(
          "dark-theme",
          darkMode,
        );
        updateChartTheme();
      }

      applyTheme();

      // Listen for system theme changes
      if (window.matchMedia) {
        window.matchMedia("(prefers-color-scheme: dark)")
          .addEventListener(
            "change",
            (e) => {
              darkMode = e.matches;
              applyTheme();
            },
          );
      }

      function updateChartTheme() {
        const gridColor = darkMode
          ? "rgba(255, 255, 255, 0.05)"
          : "rgba(0, 0, 0, 0.05)";
        const textColor = darkMode ? "#e0e0e0" : "#333333";

        chart.data.datasets[0].borderColor = darkMode
          ? "rgba(75, 192, 255, 1)"
          : "rgba(75, 192, 192, 1)";

        // Update current value color immediately
        const currentEl = document.getElementById("currentPing");
        if (currentEl.style.color !== "rgb(255, 107, 107)") { // Don't override error color
          currentEl.style.color = chart.data.datasets[0].borderColor;
        }

        chart.data.datasets[0].backgroundColor = darkMode
          ? "rgba(75, 192, 255, 0.1)"
          : "rgba(75, 192, 192, 0.1)";
        chart.options.scales.y.grid.color = gridColor;
        chart.options.scales.x.grid.color = gridColor;
        chart.options.scales.y.ticks.color = textColor;
        chart.options.scales.x.ticks.color = textColor;
        chart.options.plugins.tooltip.backgroundColor = darkMode
          ? "rgba(30, 30, 30, 0.9)"
          : "rgba(255, 255, 255, 0.9)";
        chart.options.plugins.tooltip.titleColor = darkMode
          ? "#ffffff"
          : "#000000";
        chart.options.plugins.tooltip.bodyColor = textColor;
        chart.options.plugins.tooltip.borderColor = darkMode
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(0, 0, 0, 0.1)";

        chart.update();
      }

      function formatSpeed(bytesPerSec) {
        if (!bytesPerSec) return "0 B/s";
        const units = ["B/s", "kB/s", "MB/s", "GB/s"];
        let val = bytesPerSec;
        let unitIndex = 0;
        while (val >= 1024 && unitIndex < units.length - 1) {
          val /= 1024;
          unitIndex++;
        }
        return `${val.toFixed(1)} ${units[unitIndex]}`;
      }

      function updateStats() {
        const pings = chart.data.datasets[0].data.filter((v) =>
          v !== undefined && v !== null
        );
        if (pings.length > 0) {
          const currentPing = pings[pings.length - 1];
          const avgPing = (pings.reduce((a, b) =>
            a + b, 0) / pings.length)
            .toFixed(1);
          const maxPing = Math.max(...pings);

          document.getElementById("currentPing").textContent =
            `${currentPing} ms`;
          document.getElementById("avgPing").textContent =
            `${avgPing} ms`;
          document.getElementById("maxPing").textContent =
            `${maxPing} ms`;
        }
      }

      function addDataPoint(timeString, pingValue) {
        chart.data.labels.push(timeString);
        chart.data.datasets[0].data.push(pingValue);

        if (chart.data.labels.length > MAX_DATA_POINTS) {
          chart.data.labels = chart.data.labels.slice(
            REMOVE_CHUNK_SIZE,
          );
          chart.data.datasets[0].data = chart.data.datasets[0].data
            .slice(
              REMOVE_CHUNK_SIZE,
            );
        }
      }

      function showError(msg) {
        errorBanner.textContent = msg;
        errorBanner.style.display = "block";
      }

      function hideError() {
        errorBanner.style.display = "none";
      }

      // --- New Feature Implementation ---

      // 1. Update Host
      hostInput.addEventListener("input", (e) => {
        if (e.target.value.trim() !== currentHost) {
          updateHostBtn.style.display = "flex";
        } else {
          updateHostBtn.style.display = "none";
        }
      });

      function handleUpdateHost() {
        const newHost = hostInput.value.trim();
        if (newHost) {
          currentHost = newHost;
          updateHostBtn.style.display = "none";
          hideError();

          // Clear chart for new session
          // pingValues = []; // Removed
          chart.data.labels = [];
          chart.data.datasets[0].data = [];
          chart.update();

          ws.send(
            JSON.stringify({ type: "updateHost", host: newHost }),
          );

          // Reset pause state if paused
          if (isPaused) {
            isPaused = false;
            pauseBtn.querySelector("span").textContent = "pause";
            ws.send(JSON.stringify({ type: "resume" }));
          }
        }
      }

      updateHostBtn.addEventListener("click", handleUpdateHost);

      // Allow Enter key to update host
      hostInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") handleUpdateHost();
      });

      // 2. Pause/Resume
      pauseBtn.addEventListener("click", () => {
        isPaused = !isPaused;
        pauseBtn.querySelector("span").textContent = isPaused
          ? "play_arrow"
          : "pause";
        ws.send(
          JSON.stringify({ type: isPaused ? "pause" : "resume" }),
        );
      });

      // Keyboard shortcut for Pause/Resume
      document.addEventListener("keydown", (e) => {
        if (
          e.code === "Space" && e.target.tagName !== "INPUT" &&
          e.target.tagName !== "TEXTAREA"
        ) {
          e.preventDefault(); // Prevent default spacebar action (e.g., scrolling)
          pauseBtn.click(); // Toggle the pause button
        }
      });

      // WebSocket Handling
      ws.onmessage = function (event) {
        if (isPaused) return;

        try {
          const data = JSON.parse(event.data);

          if (data.type === "networkInfo") {
            document.getElementById("publicIp").textContent =
              data.publicIp || "Unknown";

            if (data.interfaces && data.interfaces.length > 0) {
              const infos = data.interfaces.map((i) =>
                `${i.address} (${i.name})`
              ).join(", ");
              document.getElementById("localIp").textContent = infos;
            } else {
              document.getElementById("localIp").textContent =
                "Unknown";
            }
            return;
          }

          if (data.type === "error") {
            showError(data.message);
            return;
          }

          const now = new Date();
          const timeString = now.toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
          });

          let updated = false;

          if (data.ping !== undefined) {
            addDataPoint(timeString, data.ping);
            updateStats();
            lastReceivedTime = Date.now();
            hideError(); // Clear error on successful ping

            const newColor = darkMode
              ? "rgba(75, 192, 255, 1)"
              : "rgba(75, 192, 192, 1)";
            document.getElementById("currentPing").style.color =
              newColor;
            updated = true;
          }

          if (data.speed !== undefined) {
            document.getElementById("downloadSpeed").textContent =
              formatSpeed(
                data.speed.rx,
              );
            document.getElementById("uploadSpeed").textContent =
              formatSpeed(
                data.speed.tx,
              );
            // No graph update for speed
          }

          if (updated) chart.update();
        } catch (e) {
          console.error("Error processing data:", e);
        }
      };

      ws.onclose = () => {
        console.log("WebSocket connection closed");
        document.getElementById("currentPing").style.color = "#ff6b6b";
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        document.getElementById("currentPing").style.color = "#ff6b6b";
        chart.update();
      };

      // Watchdog
      setInterval(() => {
        if (isPaused) return; // Don't flag errors if manually paused

        if (ws.readyState === WebSocket.OPEN) {
          const currentTime = Date.now();
          const timeSinceLastPing = currentTime - lastReceivedTime;

          if (timeSinceLastPing >= PING_INTERVAL * 2) { // Allow some slack (2s)
            const now = new Date();
            const timeString = now.toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit",
            });
            addDataPoint(timeString, 0);

            document.getElementById("currentPing").style.color =
              "#ff6b6b";
            chart.update();
            lastReceivedTime = currentTime;
          }
        }
      }, PING_INTERVAL);
    </script>
  </body>
</html>
